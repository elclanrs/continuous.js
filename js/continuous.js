// Generated by CoffeeScript 1.7.1

/*!
 * Continuous.js
 * @author Cedric Ruiz
 * @license MIT
 */

(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(exports) {
    var Stream, StreamI, accumulate, append, chars, compose, cons, consL, curry, doStream, drop, dropWhile, each, every, f, filter, find, flatMap, flip, fold, fold1, force, head, interleave, ints, iterate, join, map, memo, meth, pluck, rand, reject, repeat, some, stream, tail, take, takeWhere, takeWhile, toArray, toObject, toStream, union, unique, without, zipWith, _fn;
    curry = function() {
      var as;
      as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return function() {
        var bs;
        bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return as[0].apply(this, as.slice(1).concat(bs));
      };
    };
    compose = function() {
      var fs;
      fs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fs.reduce(function(f, g) {
        return function() {
          var as;
          as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return f(g.apply(null, as));
        };
      });
    };
    flip = function(f) {
      return function(x, y) {
        return f(y, x);
      };
    };
    memo = function(f) {
      var store;
      store = {};
      return function(x) {
        if (x in store) {
          return store[x];
        }
        return store[x] = f(x);
      };
    };
    force = function(f) {
      return f();
    };
    cons = function(x, y) {
      return function(list) {
        return list(x, y);
      };
    };
    consL = function(x, y) {
      return cons(x, function() {
        return y;
      });
    };
    head = function(list) {
      return list(function(x) {
        return x;
      });
    };
    tail = function(xs) {
      return force(xs(function(x, y) {
        return y;
      }));
    };
    stream = function() {
      var xs;
      xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof xs[0] === 'string') {
        xs = xs[0];
      }
      if (xs.length) {
        return cons(xs[0], function() {
          return stream.apply(null, [].concat(xs.slice(1)));
        });
      }
    };
    toStream = function(xs) {
      return stream.apply(null, xs);
    };
    iterate = function(f, acc) {
      if (acc != null) {
        return cons(acc, function() {
          return iterate(f, f(acc));
        });
      }
    };
    map = function(f, xs) {
      if (xs != null) {
        return cons(f(head(xs)), function() {
          return map(f, tail(xs));
        });
      }
    };
    pluck = function(prop, xs) {
      return map((function(x) {
        return x[prop];
      }), xs);
    };
    filter = function(f, xs) {
      while ((xs != null) && !f(head(xs))) {
        xs = tail(xs);
      }
      if (xs != null) {
        return cons(head(xs), function() {
          return filter(f, tail(xs));
        });
      }
    };
    unique = function(xs) {
      var seen;
      seen = {};
      return filter((function(x) {
        if (!seen[x]) {
          return seen[x] = 1;
        }
      }), xs);
    };
    reject = function(f, xs) {
      return filter((function(x) {
        return !f(x);
      }), xs);
    };
    without = function() {
      var args, xs, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), xs = arguments[_i++];
      return filter((function(x) {
        return __indexOf.call(args, x) < 0;
      }), xs);
    };
    take = function(n, xs) {
      if (n && (xs != null)) {
        return cons(head(xs), function() {
          return take(n - 1, tail(xs));
        });
      }
    };
    takeWhile = function(f, xs) {
      if (f(head(xs))) {
        return cons(head(xs), function() {
          return takeWhile(f, tail(xs));
        });
      }
    };
    takeWhere = function(obj, xs) {
      return filter((function(x) {
        var k, v;
        return __indexOf.call((function() {
          var _results;
          _results = [];
          for (k in obj) {
            v = obj[k];
            _results.push(x[k] === v);
          }
          return _results;
        })(), false) < 0;
      }), xs);
    };
    drop = function(n, xs) {
      while (n--) {
        xs = tail(xs);
      }
      return xs;
    };
    dropWhile = function(f, xs) {
      while (f(head(xs))) {
        xs = tail(xs);
      }
      return xs;
    };
    zipWith = function(f, xs, ys) {
      if ((xs != null) && (ys != null)) {
        return cons(f(head(xs), head(ys)), function() {
          return zipWith(f, tail(xs), tail(ys));
        });
      }
    };
    interleave = function(xs, ys) {
      if (xs == null) {
        return ys;
      }
      return cons(head(xs), function() {
        return interleave(ys, tail(xs));
      });
    };
    fold = function(acc, f, xs) {
      var i;
      i = 0;
      while (xs != null) {
        acc = acc != null ? f(acc, head(xs), i) : head(xs);
        xs = tail(xs);
        i++;
      }
      return acc;
    };
    fold1 = curry(fold, null);
    toArray = curry(fold, [], function(x, y) {
      return x.concat(y);
    });
    toObject = function(xs) {
      var f, key;
      key = head(xs);
      f = function(obj, x, i) {
        if (i % 2) {
          obj[key] = x;
        } else {
          key = x;
        }
        return obj;
      };
      return fold({}, f, xs);
    };
    doStream = function(n, f, xs) {
      var i;
      i = 0;
      while (n-- && (xs != null)) {
        if ((f(head(xs), i)) === false) {
          break;
        }
        xs = tail(xs);
        i++;
      }
      return null;
    };
    each = curry(doStream, Infinity);
    find = function(x, xs) {
      var ret;
      ret = false;
      each((function(y, i) {
        if (x === y) {
          return ret = i;
        }
      }), xs);
      return ret;
    };
    some = function(f, xs) {
      var ret;
      ret = false;
      each((function(x) {
        if (f(x)) {
          return ret = true;
        }
      }), xs);
      return ret;
    };
    every = function(f, xs) {
      var ret;
      ret = true;
      each((function(x) {
        if (!f(x)) {
          return ret = false;
        }
      }), xs);
      return ret;
    };
    append = function(xs, ys) {
      var i;
      ys = toArray(ys);
      i = ys.length;
      while (i--) {
        xs = consL(ys[i], xs);
      }
      return xs;
    };
    union = compose(unique, append);
    accumulate = function(f, xs) {
      if (xs != null) {
        return f(head(xs), accumulate(f, tail(xs)));
      }
    };
    join = curry(accumulate, interleave);
    flatMap = flip(compose(join, map));
    repeat = curry(iterate, function(x) {
      return x;
    });
    ints = curry(iterate, function(x) {
      return x + 1;
    });
    rand = iterate(Math.random, Math.random());
    chars = function(start, end) {
      var f, next;
      next = null;
      f = function(x) {
        if (next === end) {
          return next = start;
        }
        return next = String.fromCharCode(1 + x.charCodeAt(0));
      };
      return iterate(f, start);
    };
    StreamI = {
      head: head,
      tail: tail,
      stream: stream,
      toStream: toStream,
      iterate: iterate,
      map: map,
      pluck: pluck,
      filter: filter,
      unique: unique,
      reject: reject,
      without: without,
      take: take,
      takeWhile: takeWhile,
      takeWhere: takeWhere,
      drop: drop,
      dropWhile: dropWhile,
      zipWith: zipWith,
      interleave: interleave,
      fold: fold,
      fold1: fold1,
      toArray: toArray,
      toObject: toObject,
      doStream: doStream,
      each: each,
      find: find,
      some: some,
      every: every,
      append: append,
      union: union,
      accumulate: accumulate,
      join: join,
      flatMap: flatMap,
      repeat: repeat,
      ints: ints,
      rand: rand,
      chars: chars,
      memo: memo
    };
    Stream = (function() {
      function Stream() {
        var xs;
        xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.xs = typeof xs[0] === 'function' ? xs[0] : toStream(xs);
      }

      Stream.prototype.get = function() {
        return this.xs;
      };

      Stream.prototype.clone = function() {
        return Stream(this.xs);
      };

      return Stream;

    })();
    _fn = function(meth, f) {
      return Stream.prototype[meth] = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.xs = f.apply(null, args.concat(this.xs));
        if (meth === 'head' || meth === 'doStream' || meth === 'each' || meth === 'find' || meth === 'some' || meth === 'every' || meth === 'fold' || meth === 'fold1' || meth === 'toArray' || meth === 'toObject') {
          return this.xs;
        }
        return this;
      };
    };
    for (meth in StreamI) {
      f = StreamI[meth];
      _fn(meth, f);
    }
    exports.StreamI = StreamI;
    return exports.Stream = Stream;
  })(typeof window !== "undefined" && window !== null ? window : module.exports);

}).call(this);

//# sourceMappingURL=continuous.map
